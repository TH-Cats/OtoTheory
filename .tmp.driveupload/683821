//
//  ArticleService.swift
//  OtoTheory
//
//  Service for loading and managing Learn articles from bundled Markdown files
//
//  SSOT参照:
//  - メイン仕様: /docs/SSOT/v3.2_SSOT.md
//  - 実装仕様: /docs/SSOT/v3.2_Implementation_SSOT.md
//  - リソース仕様: /docs/SSOT/RESOURCES_SSOT_v1.md
//
//  変更時は必ずSSOTとの整合性を確認すること
//

import Foundation

class ArticleService: ObservableObject {
    static let shared = ArticleService()
    
    @Published var articles: [LearnArticle] = []
    @Published var isLoading = false
    @Published var error: Error?
    
    private init() {
        loadArticles()
    }
    
    func loadArticles() {
        isLoading = true
        error = nil
        
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            do {
                let articles = try self?.loadBundledArticles() ?? []
                
                DispatchQueue.main.async {
                    self?.articles = articles.sorted { $0.displayOrder < $1.displayOrder }
                    self?.isLoading = false
                }
            } catch {
                DispatchQueue.main.async {
                    self?.error = error
                    self?.isLoading = false
                }
            }
        }
    }
    
    private func loadBundledArticles() throws -> [LearnArticle] {
        var articles: [LearnArticle] = []
        
        // Load Japanese articles
        if let jaArticles = try? loadArticlesFromBundle(lang: "ja") {
            articles.append(contentsOf: jaArticles)
        }
        
        // Load English articles
        if let enArticles = try? loadArticlesFromBundle(lang: "en") {
            articles.append(contentsOf: enArticles)
        }
        
        // order重複チェック
        var orderMap: [String: [Int]] = ["ja": [], "en": []]
        for article in articles {
            orderMap[article.lang]?.append(article.order)
        }

        for (lang, orders) in orderMap {
            let sortedOrders = orders.sorted()
            for i in 0..<sortedOrders.count - 1 {
                if sortedOrders[i] == sortedOrders[i + 1] {
                    print("⚠️ [ArticleService] Duplicate order \(sortedOrders[i]) found in \(lang) articles")
                }
            }
        }

        return articles
    }
    
    private func loadArticlesFromBundle(lang: String) throws -> [LearnArticle] {
        guard let resourcesURL = Bundle.main.resourceURL?.appendingPathComponent("Resources") else {
            print("❌ [ArticleService] Resources folder not found in bundle")
            return []
        }
        
        let langURL = resourcesURL.appendingPathComponent(lang)
        let langPath = langURL.path
        
        guard FileManager.default.fileExists(atPath: langPath) else {
            print("❌ [ArticleService] Resources/\(lang) folder not found at path: \(langPath)")
            // フォールバック処理を削除し、空配列を返す（無限ループ防止）
            return []
        }
        
        print("✅ [ArticleService] Found Resources/\(lang) at: \(langPath)")
        
        let fileManager = FileManager.default
        let files = try fileManager.contentsOfDirectory(atPath: langPath)
        
        var articles: [LearnArticle] = []
        
        for file in files where file.hasSuffix(".md") {
            let filePath = "\(langPath)/\(file)"
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            
            // slugはfrontmatterから取得するので、ここではファイル名だけ渡す
            let filename = file
            
            if let article = parseMarkdownArticle(content: content, lang: lang, filename: filename) {
                articles.append(article)
            }
        }
        
        return articles
    }
    
    private func parseMarkdownArticle(content: String, lang: String, filename: String) -> LearnArticle? {
        // Simple YAML frontmatter parser
        let lines = content.components(separatedBy: .newlines)
        var frontmatter: [String: String] = [:]
        var contentStartIndex = 0
        
        if lines.first == "---" {
            for (index, line) in lines.enumerated() {
                if index == 0 { continue } // Skip first ---
                if line == "---" {
                    contentStartIndex = index + 1
                    break
                }
                
                let components = line.components(separatedBy: ":")
                if components.count >= 2 {
                    let key = components[0].trimmingCharacters(in: .whitespaces)
                    let value = components[1...].joined(separator: ":").trimmingCharacters(in: .whitespaces)
                    frontmatter[key] = value
                }
            }
        }
        
        let content = contentStartIndex < lines.count ? 
            lines[contentStartIndex...].joined(separator: "\n") : 
            lines.joined(separator: "\n")
        
        // frontmatterからslugを取得（ファイル名に依存しない）
        guard let slug = frontmatter["slug"], !slug.isEmpty else {
            print("⚠️ [ArticleService] Missing or empty 'slug' in \(filename)")
            return nil
        }

        // 必須項目のバリデーション
        guard let frontmatterLang = frontmatter["lang"],
              ["ja", "en"].contains(frontmatterLang) else {
            print("⚠️ [ArticleService] Invalid or missing 'lang' in \(filename). Expected 'ja' or 'en'")
            return nil
        }

        guard let frontmatterStatus = frontmatter["status"],
              ["published", "draft", "coming"].contains(frontmatterStatus) else {
            print("⚠️ [ArticleService] Invalid or missing 'status' in \(filename). Expected 'published', 'draft', or 'coming'")
            return nil
        }

        // 既存のguard文（title, subtitle, order等）はそのまま維持
        guard let title = frontmatter["title"],
              let subtitle = frontmatter["subtitle"],
              let orderStr = frontmatter["order"],
              let order = Int(orderStr),
              let status = frontmatter["status"],
              let readingTime = frontmatter["readingTime"],
              let updated = frontmatter["updated"] else {
            print("⚠️ [ArticleService] Missing required fields in \(filename)")
            return nil
        }
        
        let keywords = frontmatter["keywords"]?.components(separatedBy: ",").map { $0.trimmingCharacters(in: .whitespaces) } ?? []
        let related = frontmatter["related"]?.components(separatedBy: ",").map { $0.trimmingCharacters(in: .whitespaces) } ?? []
        
        return LearnArticle(
            id: slug,
            title: title,
            subtitle: subtitle,
            lang: lang,
            slug: slug,
            order: order,
            status: status,
            readingTime: readingTime,
            updated: updated,
            keywords: keywords,
            related: related,
            sources: [], // TODO: Parse sources from frontmatter
            content: content
        )
    }
    
    func getAllArticles(lang: String = "ja") -> [LearnArticle] {
        return articles.filter { $0.lang == lang }
    }
    
    func getPublishedArticles(lang: String = "ja") -> [LearnArticle] {
        return articles.filter { $0.lang == lang && $0.isPublished }
    }
    
    func getArticle(slug: String, lang: String = "ja") -> LearnArticle? {
        return articles.first { $0.slug == slug && $0.lang == lang }
    }
    
    func getNextArticle(currentOrder: Int, lang: String = "ja") -> LearnArticle? {
        let publishedArticles = getPublishedArticles(lang: lang)
        return publishedArticles.first { $0.order == currentOrder + 1 }
    }
    
    func getPrevArticle(currentOrder: Int, lang: String = "ja") -> LearnArticle? {
        let publishedArticles = getPublishedArticles(lang: lang)
        return publishedArticles.first { $0.order == currentOrder - 1 }
    }
}

enum ArticleServiceError: Error {
    case bundleNotFound
    case parsingFailed
    case fileNotFound
}
